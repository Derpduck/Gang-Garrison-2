<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="DESTROY" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">{
    loopsoundstop(UberIdleSnd);
    
    var map;
    with(currentWeapon) {
        instance_destroy();
    }
    
    with(bubble) {
        instance_destroy();
    }
    
    // Drop intel if carried. This is not done by sending an extra event because that would be a nested event, which
    // screws up order of operations (Server: do part of player death, then drop intel, then do rest of player death. Client: Do player death, drop intel for dead player, error out)
    if (intel)
    {
        doEventDropIntel(player);
        
        // lastDamageSource is not always synchronized on Character destruction (e.g. if the player just leaves), so we HAVE to sync here.
        // Let's just hope it doesn't matter whether we return the intel now (Server) or after the player destruction is finished (Client).
        if (global.isHost and (lastDamageSource == DAMAGE_SOURCE_KILL_BOX || lastDamageSource == DAMAGE_SOURCE_FRAG_BOX || lastDamageSource == DAMAGE_SOURCE_PITFALL))
        {
            var intelTeam;
            if (team == TEAM_RED)
                intelTeam = TEAM_BLUE;
            else if (team == TEAM_BLUE)
                intelTeam = TEAM_RED;
            else
                show_error("Invalid team set for Character " + player.name, true);
                
            doEventReturnIntel(intelTeam);
            sendEventReturnIntel(intelTeam);
        }
    }
    
    player.object=-1;
    if place_meeting(x,y,SpawnRoom) or tdmGrace==1{
        player.alarm[5] = 1;
    }else{
        if global.isLive{
            if !instance_exists(MGE_HUD){
                player.alarm[5] = global.Server_Respawntime / global.delta_factor;
            }else{
                player.alarm[5] = 30 / global.delta_factor;
            }
        }
    }
    
    if instance_exists(MGE_HUD){
        with(Shot) if(ownerPlayer == other.player) instance_destroy();
        with(Rocket) if(ownerPlayer == other.player) instance_destroy();
        with(BurningProjectile) if(ownerPlayer == other.player) instance_destroy();
        with(Needle) if(ownerPlayer == other.player) instance_destroy();
        with(Blade) if(ownerPlayer == other.player) instance_destroy();
        with(Sentry) if(ownerPlayer == other.player) instance_destroy();
        
        if lastDamageDealer != -1 and instance_exists(lastDamageDealer){
            if lastDamageDealer.object != -1 and instance_exists(lastDamageDealer.object){
                if lastDamageDealer.MGE_currentArena=player.MGE_currentArena{
                    with(lastDamageDealer.object){
                        event_perform(ev_collision, HealingCabinet);
                        
                        if player.MGE_currentArena!=-1{
                            if team==TEAM_RED{
                                MGE_HUD.redScore[player.MGE_currentArena]+=1
                            }else if team==TEAM_BLUE{
                                MGE_HUD.blueScore[player.MGE_currentArena]+=1
                            }
                        }
                        GameServer.syncTimer=1
                    }
                }
            }
        }
    }

    if global.isHost and global.killstreakPrints==1 and killstreak&gt;=5{
        deadName=c_filter(player.name)
        colorDead=getPlayerColor(player, true)
        if killstreakEnder==-1{
            killstreakString=" killstreak has ended!"
        }else{
            killstreakEnderName=c_filter(killstreakEnder.name)
            colorEnder=getPlayerColor(killstreakEnder, true)
            killstreakString=" killstreak was ended by"+colorEnder+" "+killstreakEnderName+C_WHITE+"!"
        }
        message = global.chatPrintPrefix+colorDead+deadName+C_WHITE+"'s "+C_GREEN+string(killstreak)+C_WHITE+killstreakString
        write_ubyte(global.publicChatBuffer, CHAT_PUBLIC_MESSAGE);
        write_ushort(global.publicChatBuffer, string_length(message));
        write_string(global.publicChatBuffer, message);
        write_byte(global.publicChatBuffer,-1)
        print_to_chat(message);// For the host
    }
    
    //part type destroy
    if(variable_local_exists("jumpFlameParticleType"))
        part_type_destroy(jumpFlameParticleType);
    
    if(variable_local_exists("jumpDustParticleSystem"))
        part_type_destroy(jumpDustParticleSystem);
        
    // destroy overlay lists
    ds_list_destroy(stillOverlays);
    ds_list_destroy(leanROverlays);
    ds_list_destroy(leanLOverlays);
    ds_list_destroy(jumpOverlays);
    ds_list_destroy(runOverlays);
    ds_list_destroy(walkOverlays);
    ds_list_destroy(crouchOverlays);
    ds_list_destroy(tauntOverlays);
    ds_list_destroy(omnomnomnomOverlays);
    ds_list_destroy(gearList);
    
    //Bots
    with Player{
        if isBot{
            if target == other.id{
                target = -1
                ds_list_clear(directionList)
            }
        
            if patient == other.id{
                patient = -1
            }
        }
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
