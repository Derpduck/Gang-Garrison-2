<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="DRAW" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">xoffset = view_xview[0]
yoffset = view_yview[0]
xsize = view_wview[0]
ysize = view_hview[0]
xshift = -320*global.timerPos
yshift = 5*global.timerPos
var reddir, bluedir, redx, redy, bluex, bluey;

if (global.myself == -1){
    exit;
}
    
//Drawing intel status and arrows:
redx = xoffset+xsize/2-65
redy = yoffset+ysize-50
bluex = xoffset+xsize/2+60
bluey = yoffset+ysize-50

draw_set_alpha(1);

draw_sprite_ext(sprite_index, 0, xoffset+xsize/2+1, yoffset+ysize+100, 3, 3, 0, c_white, 1)

draw_set_color(c_black)
draw_set_valign(fa_middle)
draw_set_halign(fa_center)

//amount of caps, and the amount of caps to win
draw_text_transformed(xoffset+xsize/2-32, yoffset+ysize-40, string(global.redCaps),2,2,0)
draw_text_transformed(xoffset+xsize/2+28, yoffset+ysize-40, string(global.blueCaps),2,2,0)
// this next piece of code helps to resize the value of the numbers depending on the limit as not to overflow
if (global.caplimit &lt;= 9){
    draw_text_transformed(xoffset+xsize/2-2, yoffset+ysize-40, string(global.caplimit),2,2,0)
}else{
    draw_text(xoffset+xsize/2-2, yoffset+ysize-40, string(global.caplimit));  
}

// Point to the intel if it's on the field
var myxdir,myydir;
if (global.myself.team==TEAM_SPECTATOR or global.myself.object==-1){
    myxdir=xoffset+xsize/2
    myydir=yoffset+ysize/2
}else{
    myxdir=global.myself.object.x
    myydir=global.myself.object.y
}

if instance_exists(IntelligenceRed){
    reddir = point_direction(myxdir, myydir, IntelligenceRed.x, IntelligenceRed.y)
    if (IntelligenceRed.resetTimer &lt;= 0){
        redintelstatus = 2
    }else{
        redintelstatus = 0
    }
}else{
    reddir = point_direction(myxdir, myydir, IntelligenceBaseBlue.x, IntelligenceBaseBlue.y) //we're carrying it, it should point where we need to go
    with(Character){
        if (team == TEAM_BLUE and intel and id != global.myself.object){
            other.reddir = point_direction(myxdir, myydir, x, y) //point at the person who's carrying it
        }
    }
    redintelstatus=1
}

if instance_exists(IntelligenceBlue){
    bluedir = point_direction(myxdir, myydir, IntelligenceBlue.x, IntelligenceBlue.y)
    if (IntelligenceBlue.resetTimer &lt;= 0){
        blueintelstatus = 2
    }else{
        blueintelstatus = 0
    }
}else{
    bluedir = point_direction(myxdir, myydir, IntelligenceBaseRed.x, IntelligenceBaseRed.y)
    with(Character){
        if (team == TEAM_RED and intel and id != global.myself.object){
            other.bluedir = point_direction(myxdir, myydir, x, y)
        }
    }
    blueintelstatus=1;
}

draw_sprite_ext(IntelArrowS, 0, xoffset+xsize/2-89-9, yoffset+ysize-45, 2, 2, reddir, c_white, 1)
draw_sprite_ext(IntelArrowS, 1, xoffset+xsize/2+85+9, yoffset+ysize-45, 2, 2, bluedir, c_white, 1)

//class of currently carrying player
if !instance_exists(IntelligenceRed){
    for(i=0; i&lt;ds_list_size(global.players); i+=1){
    player=ds_list_find_value(global.players, i)
    if player.team==TEAM_BLUE and player.object!=-1{
        if player.object.intel==true{
            redCarrier=player.class
            redCarrierObject=player.object
        }
    }
    }
}else{
    redCarrier=-1
    redCarrierObject=-1
    
}
if !instance_exists(IntelligenceBlue){
    for(i=0; i&lt;ds_list_size(global.players); i+=1){
        player=ds_list_find_value(global.players, i)
        if player.team == TEAM_RED and player.object!=-1{
            if player.object.intel==true{
                blueCarrier=player.class
                blueCarrierObject=player.object
            }
        }
    }
}else{
    blueCarrier=-1
    blueCarrierObject=-1
}

if redCarrier!=-1{
    draw_sprite_ext(Icon,redCarrier,xoffset+xsize/2-100-40-9, yoffset+ysize-54,2,2,0,c_white,1)
    draw_sprite_ext(Icon,redCarrier,xoffset+xsize/2-100-40-9, yoffset+ysize-54,2,2,0,c_blue,0.2)
}
if blueCarrier!=-1{
    draw_sprite_ext(Icon,blueCarrier,xoffset+xsize/2+74+40+9, yoffset+ysize-54,2,2,0,c_white,1)
    draw_sprite_ext(Icon,blueCarrier,xoffset+xsize/2+74+40+9, yoffset+ysize-54,2,2,0,c_red,0.2)
}

if (global.myself.object != -1) if(global.myself.object.intel){
    if(global.myself.team == TEAM_BLUE){
        redintelstatus = 3
    }
    if(global.myself.team == TEAM_RED){
        blueintelstatus = 3
    }
}

//Intel return timer
if (redintelstatus == 0){
    draw_healthbar(xoffset+xsize/2-60, yoffset+ysize-27,xoffset+xsize/2-65, yoffset+ysize-56,
    (IntelligenceRed.resetTimer/INTEL_MAX_TIMER)*100,c_black,make_color_rgb(164,69,63),make_color_rgb(164,69,63),2,0,0)
}else if redCarrierObject!=-1{
    draw_healthbar(xoffset+xsize/2-60, yoffset+ysize-27,xoffset+xsize/2-65, yoffset+ysize-56,
    (redCarrierObject.intelRecharge/INTEL_MAX_TIMER)*100,c_black,make_color_rgb(164,69,63),make_color_rgb(164,69,63),2,0,0)
}
if (blueintelstatus == 0){
    draw_healthbar(xoffset+xsize/2+55, yoffset+ysize-27,xoffset+xsize/2+60, yoffset+ysize-56,
    (IntelligenceBlue.resetTimer/INTEL_MAX_TIMER)*100,c_black,make_color_rgb(72,92,103),make_color_rgb(72,92,103),2,0,0)
}else if blueCarrierObject!=-1{
    draw_healthbar(xoffset+xsize/2+55, yoffset+ysize-27,xoffset+xsize/2+60, yoffset+ysize-56,
    (blueCarrierObject.intelRecharge/INTEL_MAX_TIMER)*100,c_black,make_color_rgb(72,92,103),make_color_rgb(72,92,103),2,0,0)
}

//draw_sprite_ext(IntelStatusS, redintelstatus, xoffset+xsize/2-100, yoffset+ysize-43, 2, 2, 0, c_white, 1)
//draw_sprite_ext(IntelStatusS, blueintelstatus, xoffset+xsize/2+74, yoffset+ysize-43, 2, 2, 0, c_white, 1)

//Status of intel
draw_sprite_ext(IntelStatusESS, redintelstatus, xoffset+xsize/2-100-9, yoffset+ysize-43, 2, 2, 0, c_white, 1)
draw_sprite_ext(IntelStatusESS, blueintelstatus, xoffset+xsize/2+74+9, yoffset+ysize-43, 2, 2, 0, c_white, 1)

draw_roundtimer(xoffset, yoffset, xsize, ysize, timer)
</argument>
      </arguments>
    </action>
  </actions>
</event>
