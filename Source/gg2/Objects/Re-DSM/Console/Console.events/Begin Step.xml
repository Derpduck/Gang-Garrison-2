<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="1">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">// Expand / Collapse Button
if (mouse_check_button_pressed(mb_left))
{
    // Clicked on the expand button
    if (mouse_x &gt; expandXLeft and mouse_x &lt; expandXRight and mouse_y &gt; expandYTop and mouse_y &lt; expandYBottom)
    {
        expanded = !expanded
    }
}

var maxOutputBoxSize;
maxOutputBoxSize = (outputBoxBottom - offsetY) - (expandYBottom - expandYTop) - (boxPaddingHeight * 3);

if (expanded)
{
    // Expand the console window to cover the whole screen
    // Work out the maximum available size of the window including the expand button
    displayedLines = max(2, maxOutputBoxSize div lineSpacing);
}
else
{
    displayedLines = max(2, min(maxOutputBoxSize div lineSpacing, global.consoleLines));
}

// Input Box
// Split input text over multiple lines to prevent it running outside of the input window
displayCursorIndex = cursorIndex;
displayText = console_split_input_lines(currentText, (global.consoleWidth - (global.consoleTextPadding * 2)) div characterWidth);

// Typing cursor position
var textBeforeCursor, lastNewLineIndex, currentLineToCursor, lastNewLineIndex, currentLineTextToCursor, textAfterCursor;
// Get horizontal cursor poition on the current line
textBeforeCursor = string_copy(displayText, 1, displayCursorIndex);

if (string_count(chr(10), textBeforeCursor) &gt; 0)
    lastNewLineIndex = 1 + string_length(textBeforeCursor) - string_pos(chr(10), string_reverse(textBeforeCursor));
else
    lastNewLineIndex = 1;
currentLineToCursor = string_copy(textBeforeCursor, lastNewLineIndex, string_length(textBeforeCursor));

cursorXOffset = string_width(currentLineToCursor);

// Get line cursor is currently on
textAfterCursor = string_copy(displayText, displayCursorIndex + 1, string_length(displayText) + (displayCursorIndex - cursorIndex));

if (displayText != "")
{
    if (textAfterCursor != "" and textAfterCursor != chr(10))
    {
        cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " ")) - string_height(" ");
    }
    else
    {
        cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " "));
    }
}
else
{
    cursorYOffset = 0;
}

// Make text move up when the last line is only a line break with no text
if (string_char_at(displayText, string_length(displayText)) == chr(10))
{
    displayText += " ";
}

// Input Box size based on number of rows
var minOutputBoxSize, expandButtonSize, maxInputSize, maxRows;

// Always allow room for 2 lines of the output box + expand button
minOutputBoxSize = (2 * lineSpacing) + boxPaddingHeight;
expandButtonSize = (expandYBottom - expandYTop) + (boxPaddingHeight * 2);
maxInputSize = (inputBoxBottom - (minOutputBoxSize + expandButtonSize)) - offsetY;
maxRows = min(1 + string_count(chr(10), displayText), maxInputSize div characterHeight, maxInputBoxRows);

inputBoxRows = max(1, maxRows);

// If number of lines in text exceeds the input box, limit lines displayed
if (string_count(chr(10), displayText) + 1 &gt; inputBoxRows)
{
    // Delete any text after the end of the line the cursor is on
    // TODO: Fix scrolling back through the text not displaying the first line properly and the cursor not accounting for lines being removed (add onto cursorYOffset)
    /*var lineBreakIndex;
    textAfterCursor = string_copy(displayText, displayCursorIndex + 1, string_length(displayText) + (displayCursorIndex - cursorIndex));
    
    lineBreakIndex = string_pos(chr(10), textAfterCursor);
    if (lineBreakIndex == 0)
        lineBreakIndex = string_length(textAfterCursor)
    
    displayText = string_copy(displayText, 1, displayCursorIndex + lineBreakIndex);*/
    
    // Delete first line of text until number of rows
    while (string_count(chr(10), displayText) + 1 &gt; inputBoxRows)
    {
        lineBreakIndex = string_pos(chr(10), displayText);
        displayText = string_copy(displayText, lineBreakIndex + 1, string_length(displayText));
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
