<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="1">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">var maxOutputBoxSize;
maxOutputBoxSize = (outputBoxBottom - offsetY) - (fullscreenYBottom - fullscreenYTop) - (boxPaddingHeight * 3);

if (fullscreen)
{
    // Fullscreen the console window to cover the whole screen
    // Work out the maximum available size of the window including the fullscreen button
    displayedLines = max(2, maxOutputBoxSize div lineSpacing);
}
else
{
    displayedLines = max(2, min(maxOutputBoxSize div lineSpacing, global.consoleOutputRows));
}

// Input Box
// Split input text over multiple lines to prevent it running outside of the input window
displayCursorIndex = cursorIndex;
displayText = console_split_input_lines(currentText, (global.consoleWidth - (global.consoleTextPadding * 2)) div characterWidth);

// Typing cursor position
var textBeforeCursor, lastNewLineIndex, currentLineToCursor, lastNewLineIndex, currentLineTextToCursor, textAfterCursor;
// Get horizontal cursor poition on the current line
textBeforeCursor = string_copy(displayText, 1, displayCursorIndex);

if (string_count(chr(10), textBeforeCursor) &gt; 0)
    lastNewLineIndex = 1 + string_length(textBeforeCursor) - string_pos(chr(10), string_reverse(textBeforeCursor));
else
    lastNewLineIndex = 1;
currentLineToCursor = string_copy(textBeforeCursor, lastNewLineIndex, string_length(textBeforeCursor));

cursorXOffset = string_width(currentLineToCursor);

// Get line cursor is currently on
textAfterCursor = string_copy(displayText, displayCursorIndex + 1, string_length(displayText) + (displayCursorIndex - cursorIndex));

if (displayText != "")
{
    if (textAfterCursor != "" and textAfterCursor != chr(10))
    {
        cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " ")) - string_height(" ");
    }
    else
    {
        cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " "));
    }
}
else
{
    cursorYOffset = 0;
}

// Make text move up when the last line is only a line break with no text
if (string_char_at(displayText, string_length(displayText)) == chr(10))
{
    displayText += " ";
}

// Input Box size based on number of rows
var minOutputBoxSize, fullscreenButtonSize, maxInputSize, maxRows;

// Always allow room for 2 lines of the output box + fullscreen button
minOutputBoxSize = (2 * lineSpacing) + boxPaddingHeight;
fullscreenButtonSize = (fullscreenYBottom - fullscreenYTop) + (boxPaddingHeight * 2);
maxInputSize = (inputBoxBottom - (minOutputBoxSize + fullscreenButtonSize)) - offsetY;
maxRows = min(1 + string_count(chr(10), displayText), maxInputSize div characterHeight, maxInputBoxRows);

inputBoxRows = max(1, maxRows);

// Limit cursor to within the input box
cursorYOffset = min(cursorYOffset div characterHeight, maxRows - 1) * characterHeight;

// If number of lines in text exceeds the input box, limit lines displayed
// Delete first line of text until number of rows fits within the input box
while (string_count(chr(10), displayText) + 1 &gt; inputBoxRows)
{
    var lineBreakIndex;
    // Remove any lines after the cursor until text fits within input box
    textAfterCursor = string_copy(displayText, displayCursorIndex, string_length(displayText) + (displayCursorIndex - cursorIndex));
    // Get the last line break after the cursor
    if (string_count(chr(10), textAfterCursor) != 0)
    {
        lineBreakIndex = string_length(textAfterCursor) - string_pos(chr(10), string_reverse(textAfterCursor));
    }
    else
    {
        lineBreakIndex = 0;
    }
    
    if (lineBreakIndex != 0)
    {
        // If any lines exist after the cursor, delete the last line
        if (displayCursorIndex == 0)
            displayText = string_copy(displayText, 1, displayCursorIndex + lineBreakIndex);
        else
            displayText = string_copy(displayText, 1, displayCursorIndex + lineBreakIndex - 1);
        
        // Correct cursor line
        textAfterCursor = string_copy(displayText, displayCursorIndex + 1, string_length(displayText) + (displayCursorIndex - cursorIndex));
        
        if (textAfterCursor != "")
        {
            cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " ")) - string_height(" ");
        }
        else
        {
            cursorYOffset = string_height(string_replace_all(textAfterCursor, "#", " "));
        }
    }
    else
    {
        // No more lines after the line break; delete first line of text until number of rows reaches the row limit
        lineBreakIndex = string_pos(chr(10), displayText);
        displayText = string_copy(displayText, lineBreakIndex + 1, string_length(displayText));
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
