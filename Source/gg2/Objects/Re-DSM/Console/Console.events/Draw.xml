<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="DRAW" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">event_user(0);

draw_set_alpha(global.consoleOpacity / 100);
draw_set_color(c_black);

// Input Box
draw_rectangle(boxLeft, inputBoxTop, boxRight, inputBoxBottom, false);

// Output Box
draw_rectangle(boxLeft, outputBoxTop, boxRight, outputBoxBottom, false);

// Fullscreen Button
var spriteYOffset;
if (fullscreen)
    spriteYOffset = 2;
else
    spriteYOffset = 0;
draw_rectangle(fullscreenXLeft, fullscreenYTop, fullscreenXRight, fullscreenYBottom, false);
draw_sprite_ext(ScrollButtonS, fullscreen, fullscreenXRight - 11, fullscreenYBottom - 9 - spriteYOffset, 1, 1, 0, c_white, 1);

// Console Borders
draw_set_alpha(1);
draw_set_color(c_white);
draw_rectangle(boxLeft, inputBoxTop, boxRight, inputBoxBottom, true);
draw_rectangle(boxLeft, outputBoxTop, boxRight, outputBoxBottom, true);
draw_rectangle(fullscreenXLeft, fullscreenYTop, fullscreenXRight, fullscreenYBottom, true);

// Text
draw_set_halign(fa_left);
draw_set_valign(fa_bottom);
if (global.consoleBoldFont)
    draw_set_font(global.gg2Font);
else
    draw_set_font(global.consoleFontDSM);
// Input Box
draw_text(boxLeft + global.consoleTextPadding, inputBoxBottom - inputBoxPaddingHeight, displayText);

// Autocomplete Suggestion
draw_set_color(c_gray);
draw_text(boxLeft + global.consoleTextPadding + string_width(currentText), inputBoxBottom - inputBoxPaddingHeight, suggestedText);

// Input Cursor
if (cursorScrollDelay or cursorBlink)
{
    draw_set_color(make_color_rgb(0, 255, 0));
    draw_text(boxLeft + global.consoleTextPadding - 3 + cursorXOffset, inputBoxBottom - inputBoxPaddingHeight - cursorYOffset, "|");
    draw_set_color(c_white);
}

// Output Box
var printLine, renderString, stringOffset, colorCode;
draw_set_valign(fa_top);

var i;
for(i=0; i&lt;min(displayedLines, ds_list_size(global.consoleOutputHistory)); i+=1)
{
    var lineIndex;
    lineIndex = ds_list_size(global.consoleOutputHistory) - i - 1  - outputHistoryOffset;
    if (lineIndex &lt; 0)
        printLine = "";
    else
        printLine = ds_list_find_value(global.consoleOutputHistory, lineIndex);
    
    // Handle color codes
    if (string_pos(COL_FLAG, printLine) == 0)
    {
        // No code found; print line as normal
        draw_set_color(c_white);
        draw_text(boxLeft + global.consoleTextPadding, outputBoxBottom - (lineSpacing * (i + 1)), printLine);
    }
    else
    {
        // Split string at each color code
        stringOffset = 0;
        renderString = printLine;
        
        while (string_count(COL_FLAG, renderString) &gt; 0)
        {
            // Get the first color code in the string, and apply the color
            colorCode = string_copy(renderString, 1, COLOR_RGB_LENGTH);
            draw_set_color(get_color_code_hex(colorCode));
            
            // Remove the color code from renderString
            // Note: This assumes a color code is at the start of the string, if not it will delete the part of the string where it should be
            renderString = string_copy(renderString, 1 + COLOR_RGB_LENGTH, string_length(renderString));
            
            // Render text up to the next color code
            if (string_pos(COL_FLAG, renderString) != 0)
            {
                // Draw chunk of text in the given color, offset to the right by the previous string
                var stringChunk;
                stringChunk = string_copy(renderString, 1, string_pos(COL_FLAG, renderString) - 1);
                draw_text(boxLeft + global.consoleTextPadding + stringOffset, outputBoxBottom - (lineSpacing * (i + 1)), stringChunk);
                
                // Remove the stored string from renderString and continue until string is empty
                renderString = string_copy(renderString, string_pos(COL_FLAG, renderString), string_length(renderString));
                
                // Set starting position for next chunk of text and remove the already rendered text from the rest of the string
                stringOffset += string_width(stringChunk);
            }
            else
            {
                // No more color codes; render the rest of the string
                draw_text(boxLeft + global.consoleTextPadding + stringOffset, outputBoxBottom - (lineSpacing * (i + 1)), renderString);
            }
        }
    }
}

draw_set_font(global.gg2Font);
</argument>
      </arguments>
    </action>
  </actions>
</event>
