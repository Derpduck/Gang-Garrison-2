<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">// Handle typed input
if (keyboard_string != "")
{
    if (keyboard_string == "#")
    {
        keyboard_string = "\#";
    }
    currentText = string_copy(currentText, 0, cursorIndex) + keyboard_string + string_copy(currentText, cursorIndex + 1, string_length(currentText));
    cursorIndex += string_length(keyboard_string);
    keyboard_string = "";
    clearSuggestedText = false;
}

// Command history navigation
if (keyboard_check_pressed(vk_up))
{
    // Scroll to previous command in input history
    if (ds_list_size(global.consoleInputHistory) != 0)
    {
        inputHistoryIndex = max(0, inputHistoryIndex - 1);
        currentText = ds_list_find_value(global.consoleInputHistory, inputHistoryIndex);
        cursorIndex = string_length(currentText);
    }
    clearSuggestedText = false;
}
else if (keyboard_check_pressed(vk_down))
{
    // Scroll to next command  in input history
    inputHistoryIndex = min(ds_list_size(global.consoleInputHistory), inputHistoryIndex + 1);
    if (inputHistoryIndex == ds_list_size(global.consoleInputHistory))
    {
        currentText = "";
        cursorIndex = 0;
    }
    else
    {
        currentText = ds_list_find_value(global.consoleInputHistory, inputHistoryIndex);
        cursorIndex = string_length(currentText);
    }
    clearSuggestedText = false;
}

// Input text navigation
if (keyboard_check(vk_left) and !keyboard_check(vk_right))
{
    // Move cursor left
    if (global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            if (string_copy(currentText, cursorIndex - 1, 2) == "\#")
            {
                cursorIndex = max(0, cursorIndex - 2);
            }
            else
            {
                cursorIndex = max(0, cursorIndex - 1);
            }
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
    clearSuggestedText = false;
}
else if (keyboard_check(vk_right) and !keyboard_check(vk_left))
{
    // Move cursor right
    if(global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            if (string_copy(currentText, cursorIndex + 1, 2) == "\#")
            {
                cursorIndex = min(string_length(currentText), cursorIndex + 2);
            }
            else
            {
            cursorIndex = min(string_length(currentText), cursorIndex + 1);
            }
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
    clearSuggestedText = false;
}
else if (keyboard_check(vk_backspace))
{
    // Backspace character
    if (cursorIndex &gt; 0)
    {
        if(global.run_virtual_ticks)
        {
            if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
            {
                if (string_copy(currentText, cursorIndex - 1, 2) == "\#")
                {
                    currentText = string_copy(currentText, 0, cursorIndex - 2) + string_copy(currentText, cursorIndex + 1, string_length(currentText));
                    cursorIndex -= 2;
                }
                else
                {
                    currentText = string_copy(currentText, 0, cursorIndex - 1) + string_copy(currentText, cursorIndex + 1, string_length(currentText));
                    cursorIndex -= 1;
                }
            }
            if (cursorScrollDelay &lt; 1)
            {
                cursorScrollDelay += 1 / 15;
            }
        }
    }
    clearSuggestedText = false;
}
else if (keyboard_check(vk_delete))
{
    // Delete character
    if (cursorIndex &lt; string_length(currentText))
    {
        if(global.run_virtual_ticks)
        {
            if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
            {
                if (string_copy(currentText, cursorIndex + 1, 2) == "\#")
                {
                    currentText = string_copy(currentText, 0, cursorIndex) + string_copy(currentText, cursorIndex + 3, string_length(currentText));
                }
                else
                {
                    currentText = string_copy(currentText, 0, cursorIndex) + string_copy(currentText, cursorIndex + 2, string_length(currentText));
                }
            }
            if (cursorScrollDelay &lt; 1)
            {
                cursorScrollDelay += 1 / 15;
            }
        }
    }
    clearSuggestedText = false;
}
else
{
    cursorScrollDelay = 0;
}

// CTRL modified commands
if (ctrlHeld)
{
    if (keyboard_check(vk_delete) or keyboard_check(vk_backspace))
    {
        // Clear all typed input
        currentText = "";
        cursorIndex = 0;
        clearSuggestedText = false;
    }
    else if (keyboard_check_pressed(ord('V')))
    {
        // Paste clipboard
        if (clipboard_has_text())
        {
            var clipboard;
            clipboard = string_replace_all(clipboard_get_text(), "#", "\#");
            currentText = string_copy(currentText, 0, cursorIndex) + clipboard + string_copy(currentText, cursorIndex + 1, string_length(currentText));
            cursorIndex += string_length(clipboard);
            keyboard_clear(ord("V"));
            clearSuggestedText = false;
        }
    }
}

// Fullscreen Button
if (mouse_check_button_pressed(mb_left))
{
    // Clicked on the fullscreen button
    if (mouse_x &gt; fullscreenXLeft and mouse_x &lt; fullscreenXRight and mouse_y &gt; fullscreenYTop and mouse_y &lt; fullscreenYBottom)
    {
        fullscreen = !fullscreen;
    }
}

if (keyboard_check_pressed(global.consoleFullscreenKey))
{
    fullscreen = !fullscreen;
}

// Autocomplete suggestion
if (global.consoleAutocomplete)
{
    if (currentText != "" and !clearSuggestedText)
    {
        if (string_length(currentText) &gt;= 1 and string_length(currentText) &lt;= 12 and string_count(" ", currentText) == 0)
        {
            // Compare currently typed text against all console commands
            var i;
            for (i=0; i&lt;ds_list_size(global.consoleCommandList); i+=1)
            {
                // Current text matches start of command
                var command;
                command = ds_list_find_value(global.consoleCommandList, i);
                if (string_pos(currentText, command) == 1)
                {
                    suggestedText = string_copy(command, string_length(currentText) + 1, string_length(command));
                    break;
                }
                else
                {
                    suggestedText = "";
                }
            };
        }
        else
        {
            suggestedText = "";
        }
    }
    else
    {
        suggestedText = "";
    }
    
    // Replace current text with suggested text if tab is pressed
    // Prevent autocompletion when pressing Alt + Tab
    if (keyboard_check_pressed(vk_alt))
    {
        suggestedText = "";
        clearSuggestedText = true;
    }
    
    if (keyboard_check_direct(vk_tab) and !clearSuggestedText)
    {
        if (suggestedText != "")
        {
            currentText += suggestedText + " ";
            suggestedText = "";
            cursorIndex = string_length(currentText);
        }
        else
        {
            // Keep suggested text clear until keyboard input is received again after alt tabbing
            clearSuggestedText = true;
        }
        
        // Handle tab key press
        keyboard_lastkey = 0;
    }
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
