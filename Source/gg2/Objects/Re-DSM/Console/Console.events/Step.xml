<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">// Handle typed input
if (keyboard_string != "")
{
    currentText = string_copy(currentText, 0, cursorPosition) + keyboard_string + string_copy(currentText, cursorPosition + 1, string_length(currentText));
    cursorPosition += string_length(keyboard_string);
    keyboard_string = "";
}

// Command history navigation
if (keyboard_check_pressed(vk_up))
{
    // Scroll to previous command in input history
    if (ds_list_size(global.consoleInputHistory) != 0)
    {
        inputHistoryIndex = max(0, inputHistoryIndex - 1);
        currentText = ds_list_find_value(global.consoleInputHistory, inputHistoryIndex);
        cursorPosition = string_length(currentText);
    }
}
else if (keyboard_check_pressed(vk_down))
{
    // Scroll to next command  in input history
    inputHistoryIndex = min(ds_list_size(global.consoleInputHistory), inputHistoryIndex + 1);
    if (inputHistoryIndex == ds_list_size(global.consoleInputHistory))
    {
        currentText = "";
        cursorPosition = 0;
    }
    else
    {
        currentText = ds_list_find_value(global.consoleInputHistory, inputHistoryIndex);
        cursorPosition = string_length(currentText);
    }
}

// Input text navigation
if (keyboard_check(vk_left) and !keyboard_check(vk_right))
{
    // Move cursor left
    if (global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            cursorPosition = max(0, cursorPosition - 1);
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
}
else if (keyboard_check(vk_right) and !keyboard_check(vk_left))
{
    // Move cursor right
    if(global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            cursorPosition = min(string_length(currentText), cursorPosition + 1);
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
}
else if (keyboard_check(vk_backspace) and cursorPosition &gt; 0)
{
    // Backspace character
    if(global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            currentText = string_copy(currentText, 0, cursorPosition-1) + string_copy(currentText, cursorPosition + 1, string_length(currentText));
            cursorPosition -= 1;
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
}
else if (keyboard_check(vk_delete) and cursorPosition &lt; string_length(currentText))
{
    // Delete character
    if(global.run_virtual_ticks)
    {
        if (cursorScrollDelay == 0 or cursorScrollDelay &gt;= 1)
        {
            currentText = string_copy(currentText, 0, cursorPosition) + string_copy(currentText, cursorPosition + 2, string_length(currentText));
        }
        if (cursorScrollDelay &lt; 1)
        {
            cursorScrollDelay += 1 / 15;
        }
    }
}
else
{
    cursorScrollDelay = 0;
}

// CTRL modified commands
if (ctrlHeld)
{
    if (keyboard_check(vk_delete) or keyboard_check(vk_backspace))
    {
        // Clear all typed input
        currentText = "";
        cursorPosition = 0;
    }
    else if (keyboard_check_pressed(ord('V')))
    {
        // Paste clipboard
        if (clipboard_has_text())
        {
            var str;
            str = clipboard_get_text();
            currentText = string_copy(currentText, 0, cursorPosition) + str + string_copy(currentText, cursorPosition + 1, string_length(currentText));
            cursorPosition += string_length(str);
            keyboard_clear(ord('V'));
        }
    }
}

// Autocomplete suggestion
if (currentText != "")
{
    if (string_length(currentText) &gt;= 1 and string_count(" ", currentText) == 0)
    {
        // Compare currently typed text against all console commands
        var i;
        for (i=0; i&lt;ds_list_size(global.consoleCommandList); i+=1)
        {
            // Current text matches start of command
            var command;
            command = ds_list_find_value(global.consoleCommandList, i);
            if (string_pos(currentText, command) == 1)
            {
                suggestedText = string_copy(command, string_length(currentText) + 1, string_length(command));
                break;
            }
            else
            {
                suggestedText = "";
            }
        };
    }
    else
    {
        suggestedText = "";
    }
}
else
{
    suggestedText = "";
}

// Replace current text with suggested text if tab is pressed
if (keyboard_check_direct(vk_tab))
{
    if (suggestedText != "")
    {
        currentText += suggestedText;
        suggestedText = "";
        cursorPosition = string_length(currentText);
    }
    
    // Handle tab key press
    keyboard_lastkey = 0;
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
